diff --git a/src/ngx_stream_lua_socket_udp.c b/src/ngx_stream_lua_socket_udp.c
index a9cecbf..5641484 100644
--- a/src/ngx_stream_lua_socket_udp.c
+++ b/src/ngx_stream_lua_socket_udp.c
@@ -71,6 +71,7 @@ static int ngx_stream_lua_socket_udp_close(lua_State *L);
 static ngx_int_t ngx_stream_lua_socket_udp_resume(ngx_stream_lua_request_t *r);
 static void ngx_stream_lua_udp_resolve_cleanup(void *data);
 static void ngx_stream_lua_udp_socket_cleanup(void *data);
+static void ngx_stream_lua_req_socket_udp_block_reading(ngx_stream_lua_request_t *r);
 
 
 enum {
@@ -1032,6 +1033,24 @@ ngx_stream_lua_socket_udp_receive(lua_State *L)
 
             rc = NGX_OK;
 
+        } else if (u->chain && u->chain->buf) {
+            u->received = ngx_min((size_t) ngx_buf_size(u->chain->buf),
+                                  u->recv_buf_size);
+            ngx_memcpy(ngx_stream_lua_socket_udp_buffer,
+                       u->chain->buf->pos, u->received);
+            u->chain->buf->pos += u->received;
+            if (ngx_buf_size(u->chain->buf) <= 0) {
+                ngx_chain_t *cl = u->chain;
+                u->chain = cl->next;
+                ngx_pfree(r->pool, cl->buf->start);
+                ngx_pfree(r->pool, cl->buf);
+                ngx_pfree(r->pool, cl);
+            }
+
+            ngx_stream_lua_socket_udp_handle_success(r, u);
+
+            rc = NGX_OK;
+
         } else {
             lua_pushnil(L);
             lua_pushliteral(L, "no more data");
@@ -1759,6 +1778,9 @@ ngx_stream_lua_req_socket_udp(lua_State *L)
         return 2;
     }
 
+    u->chain = NULL;
+    r->read_event_handler = ngx_stream_lua_req_socket_udp_block_reading;
+
     cln->handler = ngx_stream_lua_socket_udp_cleanup;
     cln->data = u;
     u->cleanup = &cln->handler;
@@ -1784,5 +1806,58 @@ ngx_stream_lua_req_socket_udp(lua_State *L)
     return 1;
 }
 
+void
+ngx_stream_lua_req_socket_udp_block_reading(ngx_stream_lua_request_t *r)
+{
+    ngx_connection_t                       *c;
+    ngx_stream_lua_ctx_t                   *ctx;
+    ngx_stream_lua_socket_udp_upstream_t   *u;
+    ngx_buf_t                              *b;
+    ngx_chain_t                            *cl, **pcl;
+    ssize_t                                 n;
+
+    c = r->connection;
+
+    ctx = ngx_stream_lua_get_module_ctx(r, ngx_stream_lua_module);
+    if (ctx == NULL) {
+        goto normal_block_reading;
+    }
+
+    u = ctx->downstream;
+    if (u == NULL) {
+        goto normal_block_reading;
+    }
+
+    if(c->read->ready && c->udp) {
+        cl = ngx_palloc(r->pool, sizeof(ngx_chain_t));
+        if (cl == NULL) {
+            goto normal_block_reading;
+        }
+        b = ngx_create_temp_buf(r->pool, UDP_MAX_DATAGRAM_SIZE);
+        if (b == NULL) {
+            ngx_pfree(r->pool, cl);
+            goto normal_block_reading;
+        }
+        cl->buf = b;
+        cl->next = NULL;
+
+        n = c->recv(c, b->last, UDP_MAX_DATAGRAM_SIZE);
+        if (n <= 0) {
+            ngx_pfree(r->pool, b->start);
+            ngx_pfree(r->pool, b);
+            ngx_pfree(r->pool, cl);
+            goto normal_block_reading;
+        }
+        b->last += n;
+        pcl = &(u->chain);
+        while (*pcl != NULL) {
+            pcl = &((*pcl)->next);
+        }
+        *pcl = cl;
+    }
+
+normal_block_reading:
+    ngx_stream_lua_block_reading(r);
+}
 
 /* vi:set ft=c ts=4 sw=4 et fdm=marker: */
diff --git a/src/ngx_stream_lua_socket_udp.h b/src/ngx_stream_lua_socket_udp.h
index abcc76d..1c81a70 100644
--- a/src/ngx_stream_lua_socket_udp.h
+++ b/src/ngx_stream_lua_socket_udp.h
@@ -61,6 +61,9 @@ struct ngx_stream_lua_socket_udp_upstream_s {
 
     ngx_stream_lua_co_ctx_t                 *co_ctx;
 
+    // read from r->connection->udp->buffer
+    ngx_chain_t                             *chain;
+
     unsigned                                 waiting:1;
 
     unsigned                                 raw_downstream:1;
